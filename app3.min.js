window.addEventListener("DOMContentLoaded",(()=>{gsap.registerPlugin(ScrollTrigger),console.log(`%c${emoji}  ${author}`,"font-size: 1.5em; color: #009688;"),console.log(`%c${line}`,"color: #95a5a6;"),console.log(`%cAuthor Link: %c${authorLink}`,"color: #95a5a6;","color: #34495e; font-weight: bold;"),console.log(`%c${line}`,"color: #95a5a6;"),window.addEventListener("load",(function(){(function(){t=window.innerWidth,r=window.innerHeight,(e=new THREE.Scene).add(x),(n=new THREE.PerspectiveCamera(45,t/r,1,1e3)).position.set(0,0,45);document.getElementById("myCanvas");(o=new THREE.WebGLRenderer({antialias:!0,alpha:!0})).setClearColor(0,0),o.setSize(t,r),o.shadowMap.enabled=!0,document.body.appendChild(o.domElement),window.addEventListener("resize",l,!1),gsap.set(f.perlin,{morph:1.5}),gsap.from(x.scale,{x:1e-5,y:1e-5,z:1e-5,duration:1.2,delay:3.25,ease:"power1.inOut"}),gsap.from(x.rotation,{y:2*Math.PI,duration:1,delay:3.25,ease:"power1.inOut"});ScrollTrigger.create({trigger:".document-wrap",scrub:2,start:"top top",end:"bottom bottom",onUpdate:e=>{x.rotation.y=20.41*e.progress,e.progress<.35?gsap.to(x.position,1,{x:-24*Math.sin(Math.PI*e.progress*3),y:-4*Math.sin(Math.PI*e.progress*1.5)}):gsap.to(x.position,1,{x:0,y:0})}}),ScrollTrigger.create({trigger:".document-wrap",scrub:2,start:"top top",end:"bottom bottom",onUpdate:e=>{}}),gsap.to(x.scale,{x:1e-5,y:1e-5,z:1e-5,immediateRender:!1,scrollTrigger:{trigger:".how-it-works-card",start:"top center",end:"20% center",scrub:!0}}),gsap.to(x.scale,1,{x:1,y:1,z:1,immediateRender:!1,scrollTrigger:{trigger:".main-footer",start:"top 70%",end:"bottom bottom",scrub:!0}}),gsap.to(f.perlin,{morph:0,immediateRender:!1,scrollTrigger:{trigger:".main-footer",start:"5% 70%",end:"bottom bottom",scrub:!0}})})(),i=new THREE.HemisphereLight(s._cont,s._white,1),_backlight=new THREE.PointLight(s._white,1),_backlight.position.set(-5,-20,-20),(g=new THREE.RectAreaLight(s._white,20,3,3)).position.set(0,0,2),_rectAreaLightHelper=new THREE.RectAreaLightHelper(g),_frontlight=new THREE.PointLight(s._white,2),_frontlight.position.set(20,10,0),e.add(_backlight),e.add(i),e.add(g),e.add(_frontlight),function(n=-20){(P=new THREE.GridHelper(200,20,s._cont,s._gray)).position.y=n,e.add(P)}(),(c=new skinElement).mesh.scale.set(1,1,1),e.add(c.mesh),h()}),!1),gsap.registerPlugin(ScrollTrigger);var e,n,o,t,r,i,g,c,a,v,s={_gray:2236962,_dark:0,_cont:4473924,_blue:4095,_red:15728640,_cyan:65535,_white:15730057},x=new THREE.Object3D;function l(){t=window.innerWidth,r=window.innerHeight,o.setSize(t,r),n.aspect=t/r,n.updateProjectionMatrix()}this.textureLoader=new THREE.TextureLoader,textureLoader.crossOrigin="";var y={time:{type:"f",value:0},texture:{value:textureLoader.load("./img/dot.png")},resolution:{value:new THREE.Vector2},RGBr:{type:"f",value:0},RGBg:{type:"f",value:0},RGBb:{type:"f",value:0},RGBn:{type:"f",value:0},RGBm:{type:"f",value:0},morph:{type:"f",value:0},dnoise:{type:"f",value:0},psize:{type:"f",value:3}},f={perlin:{time:8.5,morph:1.5,dnoise:0},chroma:{RGBr:7.8,RGBg:5,RGBb:1.2,RGBn:0,RGBm:0},camera:{zoom:120,speedY:.25,speedX:.12,guide:!1},sphere:{wireframe:!1,points:!0,psize:1}};function z(e){switch(e){case"mobile":console.log("Mobile"),x.scale.set(.65,.65,.65),x.position.set(0,3.5,0),f.sphere.psize=.5,console.log("Mobile");break;case"tablet":console.log("Tablet"),x.scale.set(.5,.5,.5),f.sphere.psize=.5,x.position.set(0,4.5,0);break;case"desktop":console.log("Desktop"),x.scale.set(1,1,1),f.sphere.psize=1.5,console.log("Desktop")}}const d=window.matchMedia("(max-width: 768px)"),m=window.matchMedia("(min-width:769px) and (max-width: 1024px)"),p=window.matchMedia("(min-width: 1025px)");var P;d.matches?z("mobile"):m.matches?z("tablet"):p.matches&&z("desktop"),d.addListener((e=>{e.matches&&z("mobile")})),m.addListener((e=>{e.matches&&z("tablet")})),p.addListener((e=>{e.matches&&z("desktop")})),skinElement=function(e=5){e>=5&&(e=5),v=new THREE.IcosahedronBufferGeometry(6,5),a=new THREE.ShaderMaterial({uniforms:y,side:THREE.DoubleSide,vertexShader:"\n\n  vec3 mod289(vec3 x)\n  {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n  }\n  vec4 mod289(vec4 x)\n  {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n  }\n  vec4 permute(vec4 x)\n  {\n    return mod289(((x*34.0)+1.0)*x);\n  }\n  vec4 taylorInvSqrt(vec4 r)\n  {\n    return 1.79284291400159 - 0.85373472095314 * r;\n  }\n  vec3 fade(vec3 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n  }\n  // Classic Perlin noise\n  float cnoise(vec3 P)\n  {\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 1.2 * n_xyz;\n  }\n  // Classic Perlin noise, periodic variant\n  float pnoise(vec3 P, vec3 rep)\n  {\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.50 * n_xyz;\n  }\n  varying vec3 vNormal;\n  varying vec3 vPosition; \n  uniform float time;\n  uniform float weight;\n  uniform float morph;\n  uniform float psize;\n  \n  void main() {\n    float f = morph * pnoise( normal * 2.90 + time, vec3( 10.0 ) );\n    vNormal = normalize(normal);\n\n    vPosition = position;\n\n    vec4 pos = vec4( position - f * normal, 1.0 );\n    gl_Position = projectionMatrix * modelViewMatrix * pos;\n\n    // Calculate the size of the point in screen space\n    vec4 projectedPosition = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    gl_PointSize = psize * (35.0 / length(projectedPosition.xyz));\n    //gl_PointSize = psize;\n  }\n  ",fragmentShader:"\n\n  vec3 mod289(vec3 x)\n  {\n  return x - floor(x * (1.0 / 89.0)) * 289.0;\n  }\n  vec4 mod289(vec4 x)\n  {\n  return x - floor(x * (1.0 / 189.0)) * 289.0;\n  }\n  vec4 permute(vec4 x)\n  {\n  return mod289(((x*34.0)+1.0)*x);\n  }\n  vec4 taylorInvSqrt(vec4 r)\n  {\n  return 1.79284291400159 - 0.85373472095314 * r;\n  }\n  vec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n  }\n\n\n  // Classic Perlin noise\n  float cnoise(vec3 P)\n  {\n  vec3 Pi0 = floor(P); \n  vec3 Pi1 = Pi0 + vec3(1.0); \n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n\n  vec3 Pf0 = fract(P); \n  vec3 Pf1 = Pf0 - vec3(1.0); \n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n\n  return 2.2 * n_xyz;\n  }\n\n  // Classic Perlin noise, periodic variant\n  float pnoise(vec3 P, vec3 rep)\n  {\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n\n    gx0 = fract(gx0);\n\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 10.0 * n_xyz;\n  }\n  varying vec3 vNormal;\n  uniform sampler2D tShine;\n  uniform float time;\n  uniform float RGBr;\n  uniform float RGBg;\n  uniform float RGBb;\n  uniform float RGBn;\n  uniform float RGBm;\n  uniform float dnoise;\n  uniform sampler2D texture;\n  varying float vAlpha;\n  \nfloat PI = 3.14159265358979323846264;\n\nvec3 color2 = vec3(203.0 / 255.0, 0.0, 221.0 / 255.0); // #CB00DD\nvec3 color1 = vec3(49.0 / 255.0, 242.0 / 255.0, 191.0 / 255.0); // #3DDEED\n\nvoid main() {\n    float r = ( pnoise( RGBr * ( vNormal + time ), vec3( 10.0 ) ) );\n    float g = ( pnoise( RGBg * ( vNormal + time ), vec3( 10.0 ) ) );\n    float b = ( pnoise( RGBb * ( vNormal + time ), vec3( 10.0 ) ) );\n    float n = pnoise( -1.0 * ( vNormal + time ), vec3( 10.0 ) );\n    //n = pow( 1.0, n );\n    n = 10.0 * pnoise( (RGBn) * ( vNormal ), vec3( 10.0 ) ) * pnoise( RGBm * ( vNormal + time ), vec3( 10.0 ) );\n    n -= 0.10 * pnoise( dnoise * vNormal, vec3( 10.0 ) );\n\n    // Interpolating between color1 and color2 based on vNormal.y\n\n   float blendFactor = smoothstep(-1.0, 1.0, vNormal.y);\n    \n    //float t = (n + 1.0) / 13.0; // Map n from [-1, 1] to [0, 1]\n    vec3 finalColor = mix(color1, color2, blendFactor);\n\n    // Adding noise\n    finalColor += vec3(n);\n\n    gl_FragColor = vec4(finalColor, 1.0);\n\n    \n    gl_FragColor = vec4(finalColor, 1.0);\n    vec4 texColor = texture2D(texture, gl_PointCoord);\n    if (texColor.a < 0.75) discard; \n    gl_FragColor = gl_FragColor * texColor;\n}\n  ",wireframe:f.sphere.wireframe}),this.point=new THREE.Points(v,a),this.mesh=new THREE.Mesh(v,a),this.mesh.geometry.verticesNeedUpdate=!0,this.mesh.geometry.morphTargetsNeedUpdate=!0,this.mesh.reseivedShadow=!1,this.mesh.castShadow=!0,x.add(this.point),x.add(this.mesh)};var u=Date.now();function h(){var t=Date.now();y.time.value=f.perlin.time/1e4*(t-u),y.morph.value=f.perlin.morph,y.dnoise.value=f.perlin.dnoise,gsap.from(n.position,1,{z:150-f.camera.zoom}),c.mesh.rotation.y+=f.camera.speedY/100,c.mesh.rotation.z+=f.camera.speedX/100,c.point.rotation.y=c.mesh.rotation.y,c.point.rotation.z=c.mesh.rotation.z,P.rotation.y=c.mesh.rotation.y,a.uniforms.RGBr.value=f.chroma.RGBr/10,a.uniforms.RGBg.value=f.chroma.RGBg/10,a.uniforms.RGBb.value=f.chroma.RGBb/10,a.uniforms.RGBn.value=f.chroma.RGBn/100,a.uniforms.RGBm.value=f.chroma.RGBm,a.uniforms.psize.value=f.sphere.psize,P.visible=f.camera.guide,c.mesh.visible=!f.sphere.points,c.point.visible=f.sphere.points,a.wireframe=f.sphere.wireframe,n.lookAt(e.position),requestAnimationFrame(h),o.render(e,n)}}));