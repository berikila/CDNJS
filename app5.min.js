window.addEventListener("DOMContentLoaded",(()=>{gsap.registerPlugin(ScrollTrigger),window.addEventListener("load",(function(){(function(){t=window.innerWidth,i=window.innerHeight,(e=new THREE.Scene).add(y),(n=new THREE.PerspectiveCamera(45,t/i,1,1e3)).position.set(0,0,45);document.getElementById("myCanvas");(o=new THREE.WebGLRenderer({antialias:!0,alpha:!0})).setClearColor(0,0),o.setSize(t,i),o.shadowMap.enabled=!0,document.body.appendChild(o.domElement),window.addEventListener("resize",s,!1),gsap.set(l.perlin,{morph:.75}),gsap.from(y.rotation,{y:2*Math.PI,duration:1.5,delay:.25,ease:"power1.inOut"});function g(e){switch(e){case"mobile":console.log("Mobile"),y.scale.set(.45,.45,.45),y.position.set(0,-2.5,0),l.sphere.psize=.5,console.log("Mobile"),gsap.to(y.scale,{x:.55,y:.55,z:.55,duration:3.5,repeat:-1,yoyo:!0,ease:"expoScale(1,1.5,power2.inOut)"});break;case"tablet":console.log("Tablet"),y.scale.set(.38,.38,.38),y.position.set(5,3.25,0),console.log("Mobile"),gsap.to(y.scale,{x:.5,y:.5,z:.5,duration:3.5,repeat:-1,yoyo:!0,ease:"expoScale(1,1.5,power2.inOut)"});break;case"desktop":console.log("Desktop"),y.scale.set(.8,.8,.8),y.position.set(7,-4.5,0),console.log("Desktop"),gsap.to(y.scale,{x:1,y:1,z:1,duration:3.5,repeat:-1,yoyo:!0,ease:"expoScale(1,1.5,power2.inOut)"})}}const r=window.matchMedia("(max-width: 768px)"),c=window.matchMedia("(min-width:769px) and (max-width: 1024px)"),a=window.matchMedia("(min-width: 1025px)");r.matches?g("mobile"):c.matches?g("tablet"):a.matches&&g("desktop");r.addListener((e=>{e.matches&&g("mobile")})),c.addListener((e=>{e.matches&&g("tablet")})),a.addListener((e=>{e.matches&&g("desktop")}))})(),g=new THREE.HemisphereLight(x._cont,x._white,1),_backlight=new THREE.PointLight(x._white,1),_backlight.position.set(-5,-20,-20),(r=new THREE.RectAreaLight(x._white,20,3,3)).position.set(0,0,2),_rectAreaLightHelper=new THREE.RectAreaLightHelper(r),_frontlight=new THREE.PointLight(x._white,2),_frontlight.position.set(20,10,0),e.add(_backlight),e.add(g),e.add(r),e.add(_frontlight),function(n=-20){(f=new THREE.GridHelper(200,20,x._cont,x._gray)).position.y=n,e.add(f)}(),(c=new skinElement).mesh.scale.set(1,1,1),e.add(c.mesh),m()}),!1),gsap.registerPlugin(ScrollTrigger);var e,n,o,t,i,g,r,c,a,v,x={_gray:2236962,_dark:0,_cont:4473924,_blue:4095,_red:15728640,_cyan:65535,_white:15730057},y=new THREE.Object3D;function s(){t=window.innerWidth,i=window.innerHeight,o.setSize(t,i),n.aspect=t/i,n.updateProjectionMatrix()}this.textureLoader=new THREE.TextureLoader,textureLoader.crossOrigin="";var f,z={time:{type:"f",value:0},texture:{value:textureLoader.load("./img/dot.png")},resolution:{value:new THREE.Vector2},RGBr:{type:"f",value:0},RGBg:{type:"f",value:0},RGBb:{type:"f",value:0},RGBn:{type:"f",value:0},RGBm:{type:"f",value:0},morph:{type:"f",value:0},dnoise:{type:"f",value:0},psize:{type:"f",value:3}},l={perlin:{time:8.5,morph:1.5,dnoise:0},chroma:{RGBr:7.8,RGBg:5,RGBb:1.2,RGBn:0,RGBm:0},camera:{zoom:120,speedY:.25,speedX:.12,guide:!1},sphere:{wireframe:!1,points:!0,psize:2.5}};skinElement=function(e=5){e>=5&&(e=5),v=new THREE.IcosahedronBufferGeometry(6,5),a=new THREE.ShaderMaterial({uniforms:z,side:THREE.DoubleSide,vertexShader:"\n\n  vec3 mod289(vec3 x)\n  {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n  }\n  vec4 mod289(vec4 x)\n  {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n  }\n  vec4 permute(vec4 x)\n  {\n    return mod289(((x*34.0)+1.0)*x);\n  }\n  vec4 taylorInvSqrt(vec4 r)\n  {\n    return 1.79284291400159 - 0.85373472095314 * r;\n  }\n  vec3 fade(vec3 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n  }\n  // Classic Perlin noise\n  float cnoise(vec3 P)\n  {\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 1.2 * n_xyz;\n  }\n  // Classic Perlin noise, periodic variant\n  float pnoise(vec3 P, vec3 rep)\n  {\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.50 * n_xyz;\n  }\n  varying vec3 vNormal;\n  varying vec3 vPosition; \n  uniform float time;\n  uniform float weight;\n  uniform float morph;\n  uniform float psize;\n  \n  void main() {\n    float f = morph * pnoise( normal * 2.90 + time, vec3( 10.0 ) );\n    vNormal = normalize(normal);\n\n    vPosition = position;\n\n    vec4 pos = vec4( position - f * normal, 1.0 );\n    gl_Position = projectionMatrix * modelViewMatrix * pos;\n\n    // Calculate the size of the point in screen space\n    vec4 projectedPosition = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    gl_PointSize = psize * (35.0 / length(projectedPosition.xyz));\n    //gl_PointSize = psize;\n  }\n  ",fragmentShader:"\n\n  vec3 mod289(vec3 x)\n  {\n  return x - floor(x * (1.0 / 89.0)) * 289.0;\n  }\n  vec4 mod289(vec4 x)\n  {\n  return x - floor(x * (1.0 / 189.0)) * 289.0;\n  }\n  vec4 permute(vec4 x)\n  {\n  return mod289(((x*34.0)+1.0)*x);\n  }\n  vec4 taylorInvSqrt(vec4 r)\n  {\n  return 1.79284291400159 - 0.85373472095314 * r;\n  }\n  vec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n  }\n\n\n  // Classic Perlin noise\n  float cnoise(vec3 P)\n  {\n  vec3 Pi0 = floor(P); \n  vec3 Pi1 = Pi0 + vec3(1.0); \n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n\n  vec3 Pf0 = fract(P); \n  vec3 Pf1 = Pf0 - vec3(1.0); \n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n\n  return 2.2 * n_xyz;\n  }\n\n  // Classic Perlin noise, periodic variant\n  float pnoise(vec3 P, vec3 rep)\n  {\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n\n    gx0 = fract(gx0);\n\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 10.0 * n_xyz;\n  }\n  varying vec3 vNormal;\n  uniform sampler2D tShine;\n  uniform float time;\n  uniform float RGBr;\n  uniform float RGBg;\n  uniform float RGBb;\n  uniform float RGBn;\n  uniform float RGBm;\n  uniform float dnoise;\n  uniform sampler2D texture;\n  varying float vAlpha;\n  \nfloat PI = 3.14159265358979323846264;\n\n//vec3 color1 = vec3(190.0 / 255.0, 156.0/255.0, 251.0 / 255.0); // #CB00DD\nvec3 color2 = vec3(203.0 / 255.0, 0.0, 221.0 / 255.0); // #CB00DD\nvec3 color1 = vec3(49.0 / 255.0, 242.0 / 255.0, 191.0 / 255.0); // #3DDEED\n\nvoid main() {\n    float r = ( pnoise( RGBr * ( vNormal + time ), vec3( 10.0 ) ) );\n    float g = ( pnoise( RGBg * ( vNormal + time ), vec3( 10.0 ) ) );\n    float b = ( pnoise( RGBb * ( vNormal + time ), vec3( 10.0 ) ) );\n    float n = pnoise( -1.0 * ( vNormal + time ), vec3( 10.0 ) );\n    //n = pow( 1.0, n );\n    n = 10.0 * pnoise( (RGBn) * ( vNormal ), vec3( 10.0 ) ) * pnoise( RGBm * ( vNormal + time ), vec3( 10.0 ) );\n    n -= 0.10 * pnoise( dnoise * vNormal, vec3( 10.0 ) );\n\n    // Interpolating between color1 and color2 based on vNormal.y\n\n   float blendFactor = smoothstep(-1.0, 1.0, vNormal.y);\n    \n    //float t = (n + 1.0) / 13.0; // Map n from [-1, 1] to [0, 1]\n    vec3 finalColor = mix(color1, color2, blendFactor);\n\n    // Adding noise\n    finalColor += vec3(n);\n\n    gl_FragColor = vec4(finalColor, 1.0);\n\n    \n    gl_FragColor = vec4(finalColor, 1.0);\n    vec4 texColor = texture2D(texture, gl_PointCoord);\n    if (texColor.a < 0.75) discard; \n    gl_FragColor = gl_FragColor * texColor;\n}\n  ",wireframe:l.sphere.wireframe}),this.point=new THREE.Points(v,a),this.mesh=new THREE.Mesh(v,a),this.mesh.geometry.verticesNeedUpdate=!0,this.mesh.geometry.morphTargetsNeedUpdate=!0,this.mesh.reseivedShadow=!1,this.mesh.castShadow=!0,y.add(this.point),y.add(this.mesh)};var d=Date.now();function m(){var t=Date.now();z.time.value=l.perlin.time/1e4*(t-d),z.morph.value=l.perlin.morph,z.dnoise.value=l.perlin.dnoise,gsap.from(n.position,1,{z:150-l.camera.zoom}),c.mesh.rotation.y+=l.camera.speedY/100,c.mesh.rotation.z+=l.camera.speedX/100,c.point.rotation.y=c.mesh.rotation.y,c.point.rotation.z=c.mesh.rotation.z,f.rotation.y=c.mesh.rotation.y,a.uniforms.RGBr.value=l.chroma.RGBr/10,a.uniforms.RGBg.value=l.chroma.RGBg/10,a.uniforms.RGBb.value=l.chroma.RGBb/10,a.uniforms.RGBn.value=l.chroma.RGBn/100,a.uniforms.RGBm.value=l.chroma.RGBm,a.uniforms.psize.value=l.sphere.psize,f.visible=l.camera.guide,c.mesh.visible=!l.sphere.points,c.point.visible=l.sphere.points,a.wireframe=l.sphere.wireframe,n.lookAt(e.position),requestAnimationFrame(m),o.render(e,n)}}));